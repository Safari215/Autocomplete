#include "trie0.h"
void convUTF8toCP866(CC* a, US b) { // Используются глобальные переменные
/* Логика. Функция принимает для конвертирования указатель на си-строку и число определяющее максимально допустимое количество символов (без завершающего ноль-символа)
в результирующей строке. Предполагается, что в принятой строке содержатся UTF-8 символы. Результат работы, это си-строка, записанная в соответствующую глобальную
переменную в кодировке CP866 и не превышающая допустимую длину (лишнее обрезается). Декодируются только символы ASCII (с кодом более 31), А-Я и а-я (включая Ё и ё).
Если входящая строка пустая, то результатом, так же, будет пустая строка. Если декодируемый UTF-8 символ не входит в вышеуказанный диапазон, то вместо него будет
подставлен ASCII символ-заменитель, код которого указан в соответствующей переменной. Неопознанный символ так же будет заменён на ASCII символ-заменитель, код которого
указан в соответствующей переменной */
	US c = 0; // Счётчик символов (считаем от нуля, т.е. это индекс символа) для результирующей строки
	US d; // Нормализованное (если a[i] отрицательное, то оно конвер. в положительное) числовое значение a[i] байта исходной строки
	US e; // Нормализованное (если a[i + x] отрицательное, то оно конвер. в положительное) числовое значение a[i + x] байта исходной строки
	US f; // Вычисленный индекс UTF-8 символа
	CUS g = 95; // ASCII-код символа-заменителя для символов вне диапазона
	CUS h = 63; // ASCII-код символа-заменителя для неопознанных символов
	if (b == 0) { // Если максимально допустимая длина (без завершающего ноль-символа) результирующей строки равна нулю, "возвращаем" пустую строку
		rez[0] = 0;
		return;
	}
	if (b > rzb) b == rzb; // Ограничение на длину результирующей строки
	US i = 0; // Счётчик в цикле
	do { // Побайтно просматриваем входящую строку
		if (a[i] == 0) break; // Если дошли до конца принятой строки
		if (a[i] < 0) d = a[i] + 256; // Если числовое значение байта отрицательное, то конвертируем его в положительное
		else {
			if (a[i] < 32) d = g; // Если это ASCII-код символа управления
			else d = a[i];
		}
		if (d < 128) { // Если это ASCII-символ
			rez[c] = d;
			++c;
		}
		else if (d >= 192 && d <= 223 && a[i + 1] != 0) { // Если символ кодируется двумя байтами и второй (следующий) байт существует
			if (a[i + 1] < 0) e = a[i + 1] + 256; // Если числовое значение второго байта отрицательное, то конвертируем его в положительное
			else e = a[i + 1];
			if (e >= 128 && e <= 191) { // Если это валидное значение парного байта
				f = ((d & 31) << 6) | (e & 63); // Из двух октетов (байтов) собираем с помощью побитовых операций код UTF-8 символа
				if (f > 1039 && f < 1088) rez[c] = f - 912; // Если буквы А-п
				else if (f > 1087 && f < 1104) rez[c] = f - 864; // Если буквы р-я
				else if (f == 1025) rez[c] = f - 785; // Если буква Ё
				else if (f == 1105) rez[c] = f - 864; // Если ё
				else rez[c] = g; // Иначе (если это другой символ из рассматриваемого множества), заменяем его на код символа-заменителя
				++c;
				++i; // "Перепрыгиваем" парный октет
			}
			else { // Иначе (если значение второго байта невалидное)
				rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
				++c;
				++i; // "Перепрыгиваем" парный октет
			}
		}
		else if (d >= 192 && d <= 223 && a[i + 1] == 0) { // Если символ кодируется двумя байтами, но второй байт не существует ("обрезан" или потерялся)
			rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
			++c;
			break;
		}
		else if (d >= 224 && d <= 239 && a[i + 1] != 0 && a[i + 2] != 0) { // Если символ кодируется тремя байтами и второй и третий байт существуют
			if (a[i + 1] < 0) e = a[i + 1] + 256; // Если числовое значение второго байта отрицательное, то конвертируем его в положительное
			else e = a[i + 1];
			if (e >= 128 && e <= 191) { // Если значение второго байта валидно
				if (a[i + 2] < 0) e = a[i + 2] + 256; // Если числовое значение третьего байта отрицательное, то конвертируем его в положительное
				else e = a[i + 2];
				if (e >= 128 && e <= 191) { // Если значение третьего байта валидно
					rez[c] = g; // Символу вне диапазона присваиваем код символа-заменителя
					++c;
					i = i + 2; // "Перепрыгиваем" через триплет
				}
				else { // Иначе (если значение третьего байта невалидно)
					rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
					++c;
					i = i + 2; // "Перепрыгиваем" через триплет
				}
			}
			else { // Иначе (если значение второго байта невалидно)
					rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
					++c;
					i = i + 2; // "Перепрыгиваем" через триплет
				}
		}
		else if (d >= 224 && d <= 239 && (a[i + 1] == 0 || a[i + 2] == 0)) { // Если символ кодируется тремя байтами, но второй и/или третий байт не существует ("обрезан" или потерялся)
			rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
			++c;
			break;
		}
		else if (d >= 240 && d <= 247 && a[i + 1] != 0 && a[i + 2] != 0 && a[i + 3] != 0) { // Если символ кодируется четырьмя байтами и второй и третий и четвёртый байт существуют
			if (a[i + 1] < 0) e = a[i + 1] + 256; // Если числовое значение второго байта отрицательное, то конвертируем его в положительное
			else e = a[i + 1];
			if (e >= 128 && e <= 191) { // Если значение второго байта валидно
				if (a[i + 2] < 0) e = a[i + 2] + 256; // Если числовое значение третьего байта отрицательное, то конвертируем его в положительное
				else e = a[i + 2];
				if (e >= 128 && e <= 191) { // Если значение третьего байта валидно
					if (a[i + 3] < 0) e = a[i + 3] + 256; // Если числовое значение третьего байта отрицательное, то конвертируем его в положительное
					else e = a[i + 3];
					if (e >= 128 && e <= 191) { // Если значение четвёртого байта валидно					
						rez[c] = g; // Символу вне диапазона присваиваем код символа-заменителя
						++c;
						i = i + 3; // "Перепрыгиваем" через квартет
					}
					else { // Иначе (если значение четвёртого байта невалидно)
						rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
						++c;
						i = i + 3; // "Перепрыгиваем" через квартет
					}
				}
				else { // Иначе (если значение третьего байта невалидно)
					rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
					++c;
					i = i + 3; // "Перепрыгиваем" через квартет
				}
			}
			else { // Иначе (если значение второго байта невалидно)
					rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
					++c;
					i = i + 3; // "Перепрыгиваем" через квартет
				}
		}
		else if (d >= 240 && d <= 247 && (a[i + 1] == 0 || a[i + 2] == 0 || a[i + 3] == 0)) { // Если символ кодир. 4-мя байтами, но 2-й и/или 3-й и/или 4-й байт не существует ("обрезан" или потерялся)
			rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
			++c;
			break;
		}
		else { // Иначе (код в байте не имеет отношение к UTF-8)
			rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
			++c;
		}
		++i;
	} while (c < b); // Продолжаем пока не записали в результирующую строку максимально допустимое количество символов
	rez[c] = 0; // Зануляем результат конвертирования
}