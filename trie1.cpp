#include "trie0.h"
UC rez[rze + 1];
UC var[(rzf - rzj + 1) * rzi + 1];
UC sms[rzb - rzc - rzd - 1 + 1];
UC prf[rzb - rzc - rzd - 1 + 1];
CC* slv = "Россия Родина родина мама папа родители дедушка бабушка сын дочь дети предки брат сестра родственник тётя дядя друг товарищ приятель знакомый незнакомец коллега герой "
		  "Интернет интернет индустрия институт инструмент интерес иногда инициатива информация индивидум детский_сад школа училище техникум колледж университет академия секция кружок курсы "
		  "Андрей Светлана Анна Ольга Елена Галина Сергей Алексей Александр Николай Наталья Пётр Илья Юлия Юрий Егор Мария Вера Надежда Любовь Владимир Татьяна Дмитрий Вадим Лариса Олег "
		  "время тысячелетие столетие век пятилетка год полгода квартал месяц неделя сутки день ночь час полчаса минута секунда понедельник вторник среда четверг пятница суббота воскресенье "
		  "Солнце солнце Меркурий Венера Земля земля Луна Марс Юпитер Сатурн Уран Нептун Вселенная Галактика Космос космос вакуум звезда планета спутник метеорит атмосфера пространство "
		  "материк континент остров полуостров архипелаг Евразия Европа Азия Африка Австралия Северная_Америка Южная_Америка Антарктида Арктика равнина хребет гора овраг холм балка рельеф местность "
		  "океан море пролив залив озеро пруд болото река ручей родник исток устье водопад гейзер фонтан канал Тихий_океан Атлантический_океан Индийский_океан Северно-Ледовитый_океан "
		  "мир государство столица регион край республика область район город городское_поселение посёлок село деревня хутор станица здание строение усадьба дом квартира помещение комната кухня гараж "
		  "январь февраль март апрель май июнь июль август сентябрь октябрь ноябрь декабрь утро полдень вечер завтрак обед полдник ужин перекус вечеринка торжество юбилей свадьба день_рожденья Новый_год "
		  "произведение роман повесть рассказ изложение диктант сочинение анекдот байка поэма стихотворение повествование раздел глава абзац часть предложение слово символ книга журнал том издание "
		  "привет салют здравствуйте пока прощай до_свидания до_встречи труд общение встреча знакомство времяпровождение поездка путешествие дружба любовь зависть сочувствие чувство честь достоинство "
		  "Москва Санкт-Петербург Орёл Калуга Тверь Смоленск Тула Рязань Липецк Воронеж Ростов-на-Дону Краснодар Белгород Симферополь Севастополь Евпатория Брянск Дятьково Дружба Романовка "
		  "СССР РСФСР бСССР МГУ США Китай Индия Япония КНДР Республика_Корея Вьетнам Турция Египет Греция Германия Франция Великобритания Италия Испания Куба Аргентина Бразилия Австрия Новая_Зеландия ";
CC* t01 = "\"ЧАТИК\" МОДУЛЬ ПКЧ ПОЗВОЛЯЮЩИЙ ВВОДИТЬ ТЕКСТ С АВТОДОПОЛНЕНИЕМ, выход";
CC* t02 = "        (автодополнение реализовано только для русского языка)";
CC* t03 = "  0/71: автозавершение по цифре, отправить сообщение";
CC* t04 = "СООБЩ.:";
TrieNode* getNewNode(void) {
	struct TrieNode* a =  new TrieNode; // Выделяем память для нового узла
	for (US i = 0; i < rza; ++i) a->deti[i] = nullptr; // Инициализируем указатели на детей значением nullptr
	a->list = false; // Выставляем значение list, указывающее на то что этот узел не является концом какого-либо слова
	return a;
}
void convUTF8toCP866(CC* a, US b) { // Используются глобальные переменные
/* Логика. Функция принимает для конвертирования указатель на си-строку и число определяющее максимально допустимое количество символов (без завершающего ноль-символа)
в результирующей строке. Предполагается, что в принятой строке содержатся UTF-8 символы. Результат работы, это си-строка, записанная в соответствующую глобальную
переменную в кодировке CP866 и не превышающая допустимую длину (лишнее обрезается). Декодируются только символы ASCII (с кодом более 31), А-Я и а-я (включая Ё и ё).
Если входящая строка пустая, то результатом, так же, будет пустая строка. Если декодируемый UTF-8 символ не входит в вышеуказанный диапазон, то вместо него будет
подставлен ASCII символ-заменитель, код которого указан в соответствующей переменной. Неопознанный символ так же будет заменён на ASCII символ-заменитель, код которого
указан в соответствующей переменной */
	US c = 0; // Счётчик символов (считаем от нуля, т.е. это индекс символа) для результирующей строки
	UC d; // Нормализованное (если a[i] отрицательное, то оно конвер. в положительное) числовое значение a[i] байта исходной строки
	US e; // Нормализованное (если a[i + x] отрицательное, то оно конвер. в положительное) числовое значение a[i + x] байта исходной строки
	US f; // Вычисленный индекс UTF-8 символа
	CUS g = 95; // ASCII-код символа-заменителя для символов вне диапазона
	CUS h = 63; // ASCII-код символа-заменителя для неопознанных символов
	if (b == 0) { // Если максимально допустимая длина (без завершающего ноль-символа) результирующей строки равна нулю, "возвращаем" пустую строку
		rez[0] = 0;
		return;
	}
	if (b > rzb) b = rzb; // Ограничение на длину результирующей строки
	US i = 0; // Счётчик в цикле
	do { // Побайтно просматриваем входящую строку
		if (a[i] == 0) break; // Если дошли до конца принятой строки
		if (a[i] < 0) d = a[i] + 256; // Если числовое значение байта отрицательное, то конвертируем его в положительное
		else {
			if (a[i] < 32) d = g; // Если это ASCII-код символа управления
			else d = a[i];
		}
		if (d < 128) { // Если это ASCII-символ
			rez[c] = d;
			++c;
		}
		else if (d >= 192 && d <= 223 && a[i + 1] != 0) { // Если символ кодируется двумя байтами и второй (следующий) байт существует
			if (a[i + 1] < 0) e = a[i + 1] + 256; // Если числовое значение второго байта отрицательное, то конвертируем его в положительное
			else e = a[i + 1];
			if (e >= 128 && e <= 191) { // Если это валидное значение парного байта
				f = ((d & 31) << 6) | (e & 63); // Из двух октетов (байтов) собираем с помощью побитовых операций код UTF-8 символа
				if (f > 1039 && f < 1088) rez[c] = f - 912; // Если буквы А-п
				else if (f > 1087 && f < 1104) rez[c] = f - 864; // Если буквы р-я
				else if (f == 1025) rez[c] = f - 785; // Если буква Ё
				else if (f == 1105) rez[c] = f - 864; // Если ё
				else rez[c] = g; // Иначе (если это другой символ из рассматриваемого множества), заменяем его на код символа-заменителя
				++c;
				++i; // "Перепрыгиваем" парный октет
			}
			else { // Иначе (если значение второго байта невалидное)
				rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
				++c;
				++i; // "Перепрыгиваем" парный октет
			}
		}
		else if (d >= 192 && d <= 223 && a[i + 1] == 0) { // Если символ кодируется двумя байтами, но второй байт не существует ("обрезан" или потерялся)
			rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
			++c;
			break;
		}
		else if (d >= 224 && d <= 239 && a[i + 1] != 0 && a[i + 2] != 0) { // Если символ кодируется тремя байтами и второй и третий байт существуют
			if (a[i + 1] < 0) e = a[i + 1] + 256; // Если числовое значение второго байта отрицательное, то конвертируем его в положительное
			else e = a[i + 1];
			if (e >= 128 && e <= 191) { // Если значение второго байта валидно
				if (a[i + 2] < 0) e = a[i + 2] + 256; // Если числовое значение третьего байта отрицательное, то конвертируем его в положительное
				else e = a[i + 2];
				if (e >= 128 && e <= 191) { // Если значение третьего байта валидно
					rez[c] = g; // Символу вне диапазона присваиваем код символа-заменителя
					++c;
					i = i + 2; // "Перепрыгиваем" через триплет
				}
				else { // Иначе (если значение третьего байта невалидно)
					rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
					++c;
					i = i + 2; // "Перепрыгиваем" через триплет
				}
			}
			else { // Иначе (если значение второго байта невалидно)
					rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
					++c;
					i = i + 2; // "Перепрыгиваем" через триплет
				}
		}
		else if (d >= 224 && d <= 239 && (a[i + 1] == 0 || a[i + 2] == 0)) { // Если символ кодируется тремя байтами, но второй и/или третий байт не существует ("обрезан" или потерялся)
			rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
			++c;
			break;
		}
		else if (d >= 240 && d <= 247 && a[i + 1] != 0 && a[i + 2] != 0 && a[i + 3] != 0) { // Если символ кодируется четырьмя байтами и второй и третий и четвёртый байт существуют
			if (a[i + 1] < 0) e = a[i + 1] + 256; // Если числовое значение второго байта отрицательное, то конвертируем его в положительное
			else e = a[i + 1];
			if (e >= 128 && e <= 191) { // Если значение второго байта валидно
				if (a[i + 2] < 0) e = a[i + 2] + 256; // Если числовое значение третьего байта отрицательное, то конвертируем его в положительное
				else e = a[i + 2];
				if (e >= 128 && e <= 191) { // Если значение третьего байта валидно
					if (a[i + 3] < 0) e = a[i + 3] + 256; // Если числовое значение третьего байта отрицательное, то конвертируем его в положительное
					else e = a[i + 3];
					if (e >= 128 && e <= 191) { // Если значение четвёртого байта валидно					
						rez[c] = g; // Символу вне диапазона присваиваем код символа-заменителя
						++c;
						i = i + 3; // "Перепрыгиваем" через квартет
					}
					else { // Иначе (если значение четвёртого байта невалидно)
						rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
						++c;
						i = i + 3; // "Перепрыгиваем" через квартет
					}
				}
				else { // Иначе (если значение третьего байта невалидно)
					rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
					++c;
					i = i + 3; // "Перепрыгиваем" через квартет
				}
			}
			else { // Иначе (если значение второго байта невалидно)
					rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
					++c;
					i = i + 3; // "Перепрыгиваем" через квартет
				}
		}
		else if (d >= 240 && d <= 247 && (a[i + 1] == 0 || a[i + 2] == 0 || a[i + 3] == 0)) { // Если символ кодир. 4-мя байтами, но 2-й и/или 3-й и/или 4-й байт не существует ("обрезан" или потерялся)
			rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
			++c;
			break;
		}
		else { // Иначе (код в байте не имеет отношение к UTF-8)
			rez[c] = h; // Неопознанному символу присваиваем код символа-заменителя
			++c;
		}
		++i;
	} while (c < b); // Продолжаем пока не записали в результирующую строку максимально допустимое количество символов
	rez[c] = 0; // Зануляем результат конвертирования
}
void insKey(TrieNode* r_Aa, CUC* a) { // Используются глобальные переменные
/* Логика. На вход функция принимает си-строку unsigned char. Символы А-Я, а-я (включая Ё и ё)), дефис и знак нижнего подчёркивания
в кодировке ASCII+CP866. Слово добавляется в структуру префиксного дерева, если его нет. Если принятый ключ является префиксом в структуре
дерева (или словом), то, соответствующий узел помечается (заново помечается) листовым для этого ключа. Нулевое, слишком длинное (короткое)
или содержащее недопустимые символы слово в дерево не добавляется */
	if (r_Aa == nullptr) return; // Если структура для добавления слова не существует
	US b = 0; // Количество символов (без завершающего ноль-символа) в принятой строке
	while (a[b] != 0) { // Оцениваем количество символов в принятой строке
		++b;
		if (b == rzf + 1) return; // Если исходная строка превышает допустимую длину или (возможно) нулевая (0Б)
	}
	if (b < 1 || b < rzg) return; // Если исходная строка слишком короткая
	for (US i = 0; i < b; ++i) if (a[i] < 45 || (a[i] > 45 && a[i] < 95) || (a[i] > 95 && a[i] < 128) || ((a[i] > 175 && a[i] < 224)) || a[i] > 241) return; // Проверка символов слова на валидность
	US c; // Индекс символа принятого слова в структуре префиксного дерева (например, буква "А" имеет индекс ноль)
	TrieNode* d = r_Aa; // Создаём указатель на указатель корневого узла префиксного дерева
	for (US i = 0; i < b; ++i) { // Последовательно, символ за символом, добавляем ключ в префиксное дерево
		if (a[i] > 127 && a[i] < 176) c = a[i] - 128; // Если это буква из диапазона А-Я и а-п
		else if (a[i] > 223 && a[i] < 242) c = a[i] - 176; // Если это буква из диапазона р-я, Ё и ё
		else if (a[i] == 45) c = 66; // Если это дефис
		else c = 67; // Значит это знак нижнего подчёркивания
		if (d->deti[c] == nullptr) d->deti[c] = getNewNode(); // Если такой префикс отсутствует, то создаём новый узел
		d = d->deti[c]; // Перемещаемся далее по структуре дерева
	}
	d->list = 1; // Помечаем последний узел как лист (конец слова)
}
void bldTrie(TrieNode* r_Aa) { // Используется глобальные переменные
/* Логика. Побайтно просматривается словарь. Считанное слово конвертируется из UTF-8 в CP866, а затем, добавляется в префиксное дерево */
	UI a = 0; // Счётчик количество байт в ПРС
	char b[rzf * 4 + 1]; // Си-срока для очередного считанного слова из ПРС
	US c = 0; // Счётчик количества байт в считанном слове из ПРС
	while (slv[a] != 0) { // Считываем данные из ПРС (посимвольно)
		if (slv[a] == 32) { // Если пробел
			if (c > 0) { // Если есть считанное слово
				b[c] = 0; // "Зануляем" считанное слово
				convUTF8toCP866(b, rzf); // Конвентируем считанное слово
				insKey(r_Aa, rez); // Добавляем в префиксное дерево считанное слово
				c = 0; // Обнуляем счётчик байт считанного слова
			}
		}
		else {
			b[c] = slv[a]; // Побайтно собираем слово
			++c;
		}
		if (a == rzh * 4 + 2) return; // Если ПРС превышает допустимую длину или (возможно) нулевой (0Б)
		++a;
	}
}
US findWords(TrieNode* r_Aa, CUC* a, US e) { // Используется глобальные переменные
/* Логика. На вход функция принимает си-строку unsigned char. Символы А-Я, а-я (включая Ё и ё)), дефис и знак нижнего подчёркивания
в кодировке ASCII+CP866 и код поиска. Префикс и код поиска проверяются на валидность. При поиске в два захода, алгоритм откидывает
совпадающие слова. Например: "Интернет" и "интернет"; в приведённом примере второй результат поиска удаляется */
	if (r_Aa == nullptr) return 0; // Если структура для поиска не существует
	if (e < 1 || e > 3) return 0; // Если значение кода поиска невалидно (можно: 1 - ищем слова (совпадения по префиксу) с большой буквы, 2 - с маленькой буквы и 3 - с большой и маленькой)
	if (rzi == 0) return 0; // Если максимально допустимое количество предлагаемых пользователю слов по введённому префиксу равно нулю
	US b = 0; // Количество символов (без завершающего ноль-символа) в принятой строке
	while (a[b] != 0) { // Оцениваем количество символов в принятой строке
		++b;
		if (b == rzf + 1) return 0; // Если исходная строка превышает допустимую длину или (возможно) нулевая (0Б)
	}
	if (b < rzj) return 0; // Если префикс слишком короткий
	if (e == 2 && (a[0] < 160 || (a[0] > 175 && a[0] < 224) || a[0] == 240 || a[0] > 241)) return 0; // Если надо искать слова начинающиеся с маленькой буквы, но префикс не начинается с маленькой буквы
	if ((a[0] < 128 && a[0] > 159) && a[0] != 240) return 0; // Иначе, если префикс не начинается с прописной буквы
	US c; // Индекс символа принятого слова в структуре префиксного дерева (например, буква "А" имеет индекс ноль)
	TrieNode* d = r_Aa; // Создаём указатель на указатель корневого узла префиксного дерева и заходим в корневой узел структуры
	US g = 0; // Счётчик количества символов в си-строке с вариантами найденных по префиксу слов
	US h = 0; // Регистратор количества найденных слов в первой структуре (при последовательном поиске в двух деревьях)
	US z = 0; // Количество найденных (возвращаемое функцией значение) по префиксу слов
	if (a[0] > 127 && a[0] < 176) c = a[0] - 128; // Если это буква из диапазона А-Я и а-п
	else c = a[0] - 176; // Если это буква из диапазона р-я, Ё и ё
	if (e != 3) e = 1; // Теперь эта переменная определяет количество циклов поиска (один раз)
	else e = 2; // Иначе, в дереве производим поиск два раза (префикс начинается с большой буквы и префикс начинается с маленькой (меняем строчную на прописную) буквы)
	for (US i = 0; i < e; ++i) { // Просматриваем необходимое количество раз (основной цикл)
		if (e == 2) { // Если ищем в два захода
			if (i == 1) { // Если производим поиск в структуре второй раз (преобразуем первый символ префикса из верхнего в нижний регистр)
				d = r_Aa; // Заходим опять в корневой узел структуры
				if (a[0] == 240) c = 65; // Если это буква Ё
				else c = a[0] - 96; // Иначе, если это буква из диапазона А-Я
			}
		}
		if (d->deti[c] == nullptr) { // Если в дереве совпадение по первому символу префикса отсутствует
			if (e == 1 || i == 1) return z; // Если в дереве ищем один раз или второй раз из двух
			else continue; // Иначе, если поиск производится в два захода (и нет совпадения) переходим к поиску ещё раз
		}
		d = d->deti[c]; // Перемещаемся далее по структуре дерева
		US f = 1; // Счётчик цикла внешний
		for (; f < b; ++f) { // Последовательно ищем оставшуюся часть префикса в соответствующем словаре
			if (a[f] > 127 && a[f] < 176) c = a[f] - 128; // Если это буква из диапазона А-Я и а-п
			else if (a[f] > 223 && a[f] < 242) c = a[f] - 176; // Если это буква из диапазона р-я, Ё и ё
			else if (a[f] == 45) c = 66; // Если это дефис
			else if (a[f] == 95) c = 67; // Если это знак нижнего подчёркивания
			else { // Иначе, если символ префикса не из диапазона
				if (e == 1 || i == 1) return z; // Если ищем в структуре один раз или ищем второй раз из двух
				else break; // Иначе, если поиск производится в два захода (и нет совпадения) выходим из цикла
			}
			if (d->deti[c] == nullptr) { // Если в дереве совпадение по очередному символу префикса отсутствует
				if (e == 1 || i == 1) return z; // Если ищем в структуре один раз или ищем второй раз из двух
				else break; // Иначе, если поиск производится в два захода (и нет совпадения) выходим из цикла
			}
			d = d->deti[c]; // Перемещаемся далее по структуре дерева
		}
		if (f < b) continue; // Если был преждевременный выход из цикла переходим к поиску в дереве второй раз
		TrieNode* m = d; // Создаём указатель на указатель последнего символа префикса в структуре дерева (он поможет нам двигаться "назад" по структуре дерева)
		UC n[rzf - rzj]; // Маршрут (маршруты) в структуре префиксного дерева по существующим буквам после префикса
		US o = 0; // Индекс последнего элемента в маршруте
		n[o] = 0; // Выставляем позицию поиска (возможного ребёнка для последнего символа префикса) в ноль
		bool p; // Регистратор дальнейших действий алгоритма: 0 - не смогли продвинуться вперёд или назад (конец алгоритма) и 1 - сделали шаг вперёд или назад
		do { // Собираем (ищем) слова (самая сложная часть алгоритма)
			f = 0; // Теперь это регистратор совпадения слов в структурах
			p = 0; // Пока нет шага вперёд или назад, взводим регистратор действий на завершение алгоритма
			for (UC j = n[o]; j < rza; ++j) { // Ищем продолжение префикса
				if (d->deti[j] != nullptr) { // Если есть продолжение
					d = d->deti[j]; // Делаем шаг вперёд по структуре дерева
					if (j < 48) var[g] = j + 128; // Если это буква из диапазона А-Я и а-п
					else if (j > 47 && j < 66) var[g] = j + 176; // Если это буква из диапазона р-я, Ё и ё
					else if (j == 66) var[g] = 45; // Если это дефис
					else var[g] = 95; // Значит это знак нижнего подчёркивания
					++g; // Смещаемся вперёд на символ в результирующей строке с вариантами слов
					n[o] = j; // Фиксируем точку (код буквы) в маршруте
					++o; // Смещаемся вперёд на шаг по маршруту
					n[o] = 0; // Выставляем позицию поиска (возможного ребёнка для текущего узла) с нуля
					if (d->list == 1) { // Если это конец слова
						if (h > 0 && i == 1) { // Если ищем в два захода, в 1-вом что-то нашли и поиск в структуре идёт второй раз
							US r = 0; // Индекс сравниваемого символа в строке с вариантами слов
							US s; // Код символа в CP866 преобразованный из порядкового номера буквы в алфавите
							US t; // Счётчик цикла внешний
							for (US k = 0; k < h; ++k) { // Начинаем сравнение последнего найденного слова с найденными ранее словами в 1-ой просматриваемой структуре на факт совпадения
								for (t = 0; t < o; ++t) { // Посимвольное сравнение последнего найденного слова с очередным словом из 1-ой структуры
									if (var[r] == 32) { // Если в строке с вариантами слов встретили разделяющий (слова) пробел
										++r; // Сдвигаемся на шаг вперёд по строке
										break;
									}
									if (n[t] < 48) s = n[t] + 128; // Если это буква из диапазона А-Я и а-п
									else if (n[t] > 47 && n[t] < 66) s = n[t] + 176; // Если это буква из диапазона р-я, Ё и ё
									else if (n[t] == 66) s = 45; // Если это дефис
									else s = 95; // Значит это знак нижнего подчёркивания
									if (s != var[r]) {
										do {
											++r; // Сдвигаемся на шаг вперёд по строке
										} while (var[r] != 32); // Продолжаем пока не встретим разделяющий пробел
										++r; // Переводим индекс на начало следующего слова
										break;
									}
									++r; // Продолжаем просматривать строку
								}
								if (t == o && var[r] == 32) { // Если нашли совпадение
									while (var[g - 1] != 32) { // Продолжаем (цикл) пока предыдущий элемент строки не является разделителем (пробелом) между словами
										--g; // Смещаемся на шаг назад (затираем совпадающее слово)
									}
									f = 1; // Зарегистрировали факт нахождения совпадения
									break;
								}
							}
						}
						if (f != 1) { // Если совпадения слов в структурах не нашли
							var[g] = 32; // Добавляем пробел после слова
							++g; // Смещаемся вперёд на символ в результирующей строке с вариантами слов
							++z; // Увеличиваем счётчик найденных слов по префиксу
						}
						if (z == rzi) { // Если нашли максимально допустимое количество слов по префиксу
							var[g] = 0; // Зануляем строку с вариантами слов
							return z;
						}
						if (e == 2) { // Если ищем варианты слов по префиксу в два захода
							if (i == 0) h = z; // Если поиск идёт в первый заход, то, запоминаем количество найденных ранее слов в этом заходе (слова начинаются с большой буквы)
						}
						for (US k = 0; k < o; ++k) { // Добавляем это слово (без пробела в конце) ещё раз в строку с вариан. слов, т.к. возможно, что это слово (или его начальные символы) могут являться частью другого слова
							if (n[k] < 48) var[g] = n[k] + 128; // Если это буква из диапазона А-Я и а-п
							else if (n[k] > 47 && n[k] < 66) var[g] = n[k] + 176; // Если это буква из диапазона р-я, Ё и ё
							else if (n[k] == 66) var[g] = 45; // Если это дефис
							else var[g] = 95; // Значит это знак нижнего подчёркивания
							++g; // Смещаемся вперёд на символ в результирующей строке с вариантами слов
						}
					}
					p = 1; // Смогли сделать шаг вперёд
					break;
				}
			}
			if (p == 0) { // Иначе (если шаг вперёд не получился) пробуем сделать шаг назад
				if (o > 0) { // Если ещё можно сделать шаг назад
					d = m; // Выставляем наш указатель на узел, соответствующий последнему символу префикса, т.к. по этой структуре можно двигаться только в одном направлении (от корня)
					--o; // Делаем индекс предпоследней точки маршрута последним
					for (US j = 0; j < o; ++j) d = d->deti[n[j]]; // Делаем шаг назад за счёт перемещения по маршруту от последнего символа префикса до предпоследней точки маршрута
					++n[o]; // Смещаемся дальше по алфавиту в структуре узла префиксного дерева
					p = 1; // Смогли сделать шаг назад
					if (g > 1 && var[g - 1] != 32) --g; // Если в строке более одного символа и последний символ не является разделяющим пробелом, необходимо при шаге назад удалить последний символ
					else if (g == 1) g = 0; // Иначе, если в стоке остался один символ (он первый и не важно какой) то его неоходимо удалить (сделать шаг назад), что равносильно обнулению строки
				}
			}
		} while (p != 0); // Если сделали шаг вперёд или назад, то продолжаем цикл
	}
	var[g] = 0; // Зануляем строку с вариантами слов
	return z;
}
BOOL ShowConsoleCursor(BOOL bShow) { // Код (функции скрытия каретки) взят с сайта "Форум программистов" у пользователя с ником "586"
    CONSOLE_CURSOR_INFO cci;
    HANDLE hStdOut;
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if(hStdOut == INVALID_HANDLE_VALUE) return FALSE;
    if(!GetConsoleCursorInfo(hStdOut, &cci)) return FALSE;
    cci.bVisible = bShow;
    if(!SetConsoleCursorInfo(hStdOut,&cci)) return FALSE;
    return TRUE;
}
void entTextAuto(TrieNode* r_Aa) {
/* Логика. Пользователю предоставляется строка для ввода текста сообщения. Есть ограничение (и счётчик) по количеству введённых символов.
Если есть чем дополнить ввод, ниже, построчно, появляются варианты автодополнения. Предлагая варианты, алгоритм учитывает регистр первого
символа в слове. Например, если это начало предложения или слово внутри предложения, то, варианты будут разными */
	while (1) {
		HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE); // дескриптор (HANDLE - это тип данных, используемый для представления дескриптора объекта; GetStdHandle - это функция, которая возвращает дескриптор стандар. выход. потока)
		CUS r = 15; // Цвет шрифта для "горячих клавиш" и текста автодополнения
		system("cls");
		convUTF8toCP866(t01, rzb);
		cout << rez;
		cout << " (";
		SetConsoleTextAttribute(hnd, (((0 << 4) | r)));
		cout << "Esc";
		SetConsoleTextAttribute(hnd, (((0 << 4) | 7)));
		cout << ")" << endl;
		convUTF8toCP866(t02, rzb);
		cout << rez << endl;
		convUTF8toCP866(t03, rzb);
		cout << rez;
		cout << " (";
		SetConsoleTextAttribute(hnd, (((0 << 4) | r)));
		cout << "Enter";
		SetConsoleTextAttribute(hnd, (((0 << 4) | 7)));
		cout << ")" << endl;
		convUTF8toCP866(t04, rzc);
		cout << rez;
		US a; // Считанный после нажатия клавиши код
		UC b; // Соответствующий коду (после нажатия клавиши) символ
		US c = 0; // Счётчик символов в тексте сообщения
		short d = rzc + rzd; // Начальная позиция (отсчёт от нуля) курсора по оси X для строки с текстом сообщения
		short e = 3; // Координата (отсчёт от нуля) Y для строки с текстом сообщения
		short f = 6; // Начальная позиция (отсчёт от нуля) курсора по оси X для строки автодополнения
		short g = e + 1; // Координата Y для первой строки автодополнения
		short h = 1; // Начальная позиция курсора по оси X для информационной строки
		short m = e - 1; // Координата Y для информационной строки
		US n = 0; // Счётчик количества символов в префиксе
		US o = 0; // Количество найденных слов по префиксу
		US p = 0; // Регистратор предыдущего состояния строки автодополнения (0 - пустая, цифра - количество строк которые необходимо очистить)
		short x = d; // Отслеживаемая (в строке сообщения) координата курсора по оси X
		short y = e; // Отслеживаемая (в строке автодополнения) координата курсора по оси Y
		SetConsoleCursorPosition(hnd, {x, y});
		while (1) {
			a = _getch(); // После нажатия клавиши получаем код символа в ASCII+CP866. Для некоторых клавиш (напр. Alt) функция не возвращает код, а для функ-ных или клавиш со стрелками функцию необходимо вызывать дважды
			if ((a == 13 && c > 0) || a == 27) break; // Если был нажат Enter (и строка с текстом сообщения не пустая) или Esc
			if ((a == 0 || a == 224) && _kbhit()) a = 1000 + _getch(); // Если была нажата функцион. или клавиша со стрелкой, считываем код 2-ой раз и увелич. значение кода на 1000 что бы не пересекаться с кодами ASCII+CP866
			if (a > 31 && a < 253 && c < rzb - rzc - rzd - 1)  { // Если считанный код находится в диапазоне ASCII+CP866 и ещё не достигли конца строки
				if (o != 0 && a > 48 && a - 48 <= o) { // Если поиск по префиксу дал результат и пользователь воспользовался автодополнением
					if (a == 49) { // Если была введена цифра один
						US i = 0;
						do { // Обрабатываем выбранный пользователем вариант завершения слова
							if (var[i] == 95) { // Если в завершающей части слова встретили символ нижнего подчёркивания
								cout << " "; // Вместо символа нижнего подчёркивания на экран выводится пробел
								sms[c] = 32; // Вместо символа нижнего подчёркивания в строку с текстом сообщения заносится пробел
							}
							else {
								cout << var[i]; 
								sms[c] = var[i];
							}
							++c;
							prf[n] = var[i];
							++n;
							if (c == rzb - rzc - rzd - 1) { // Если дошли до конца строки
								n = 0;
								break;
							}
							++i;
						} while (var[i] != 32); // Продолжаем пока не встретили пробел
						prf[n] = 0;
					}
					else {
						US i = 0;
						US j = 1;
						while (1) { // Ищем необходимое слово (оно будет вторым или дальше)
							do { // Пропускаем первое или следующее неподходящее слово
								++i;
							} while (var[i] != 32); // Продолжаем пока не встретили пробел
							++i;
							++j;
							if (j == a - 48) { // Если дошли до необходимого слова
								do { // Обрабатываем выбранный пользователем вариант завершения слова
									if (var[i] == 95) {
										cout << " ";
										sms[c] = 32;
									}
									else {
										cout << var[i]; 
										sms[c] = var[i];
									}
									++c;
									prf[n] = var[i];
									++n;
									if (c == rzb - rzc - rzd - 1) { // Если дошли до конца строки
										n = 0;
										break;
									}
									++i;
								} while (var[i] != 32); // Продолжаем пока не встретили пробел
								prf[n] = 0;
								break;
							}
						}
					}
				}
				else {
					b = a; // Преобразовываем его (код) в символ
					cout << b;
					sms[c] = b;
					++c;
					if (b != 32) { // Если введённый пользователем символ не является пробелом
						prf[n] = b; // Добавляем символ в префикс
						++n;
						prf[n] = 0; // Зануляем префикс
					}
					else { // Иначе, если был введён пробел, обнуляем префикс
						n = 0;
						prf[n] = 0;
					}
				}
			}
			else if (a == 8 && c > 0) { // Если был нажат Bksp и строка сообщения не пустая (реализуем удаление последнего символа в строке сообщения и добавляем символ в префикс)
				--c;
				--x;
				SetConsoleCursorPosition(hnd, {x, y});
				cout << " "; // "Стираем" последний символ в строке текста сообщения
				if (n > 0) { // Если префикс не пустой
					--n;
					prf[n] = 0;
				}
				else if (c > 0 && sms[c - 1] != 32) { // Иначе, добавляем в префикс последнее слово из строки сообщения
					US i = c - 1; // Индекс последнего символа в строке сообщения
					do { // Считаем количество символов в последнем слове строки сообщения (считаем с конца строки)
						++n; // Счётчик количества символов (все символы кроме пробела) в последнем слове строки сообщения
						--i;
						if (i == 0) { // Если дошли до первого символа (он имеет нулевой индекс) в строке не встретив по дороге пробел
							if (sms[i] != 32) ++n; // Если первый символ в строке сообщения не является пробелом
							break;
						}
					} while (sms[i] != 32); // Продолжаем считать пока не встретим пробел
					for (i = 0; i < n; ++i) prf[i] = sms[c - n + i]; // Копируем последнее слово из строки сообщения в префикс
					prf[n] = 0;
				}
			}
			ShowConsoleCursor(FALSE);
			if (n < rzj) o = 0; // Если в префиксе не набрали достаточное количество символов
			else { // Иначе, ищем совпадения по префиксу в соответствующих структурах (только в первой, второй или обеих)
				if ((prf[0] > 159 && prf[0] < 176) || (prf[0] > 223 && prf[0] < 240) || prf[0] == 241) o = findWords(r_Aa, prf, 2); // Если префикс начинается с маленькой буквы ищем только во второй структуре
				else if ((prf[0] > 127 && prf[0] < 160) || prf[0] == 240) { // Если префикс начинается с прописной буквы
					if (n == c) o = findWords(r_Aa, prf, 3); // Если это начало строки с сообщением, ищем в двух структурах
					else {
						short s = c - n - 2; // Счётчик цикла внешний
						for (; s >= 0; --s) { // Последовательно посимвольно просматриваем строку перед префиксом в поисках ".", "!" или "?" (конца предыдущего предложения)
							if (sms[s] != 32 && sms[s] != 46 && sms[s] != 33 && sms[s] != 63) { // Если это не (" ", ".", "!" или "?"), значит, с высокой долей вероятности, префикс находится внутри предложения
								o = findWords(r_Aa, prf, 1); // Ищем только в первой структуре (слова начинаются с большой буквы)
								break;
							}
							else if (sms[s] == 46 || sms[s] == 33 || sms[s] == 63) { // Если это (".", "!" или "?"), т.е. префикс является (с высокой долей вероятности) началом следующего предложения в сообщении
								o = findWords(r_Aa, prf, 3); // Ищем в двух структурах
								break;
							}
						}
						if (s == -1) o = findWords(r_Aa, prf, 3); // Перед префиксом были одни пробелы, ищем в двух структурах
					}
				}
				else o = 0;
			}
			if (p != 0) { // Если строка (строки) автодополнения не пустая, то, необходимо её очистить от предыдущих данных
				y = g; // Выставляем начальное положение по оси Y
				SetConsoleCursorPosition(hnd, {f, y}); // Переходим на начальную строку автодополнения
				for (US i = 0; i < p; ++i) { // Очистка строк
					for (US j = 0; j < rzb - f; ++j) cout << " "; // Очистка очередной строки
					++y;
					SetConsoleCursorPosition(hnd, {f, y}); // Устанавливаем каретку на новую строку
				}
				p = 0; // Запомнили что всё почистили
			}
			if (c < rzb - rzc - rzd - 1 && o > 0) { // Если строка сообщения не заполнена до конца и поиск по префиксу дал результат
				y = g; // Выставляем начальное положение по оси Y
				p = o; // Запоминаем сколько строк необходимо будет потом очистить
				US q = 0; // Счётчик для количества символов (он же индекс в массиве) в строке с вариантами слов
				SetConsoleTextAttribute(hnd, (((0 << 4) | r)));
				for (US i = 1; i <= o; ++i) { // Построчно выводим варианты слов
					SetConsoleCursorPosition(hnd, {f, y}); // Переходим на строку автодополнения
					cout << i << " "; // Выводим номер хоткея
					SetConsoleTextAttribute(hnd, (((0 << 4) | 7)));
					for (US j = 0; j < n; ++j) {
						if (prf[j] == 95) cout << " "; // Если в префиксе содержится знак нижнего подчёркивания, то, на экране он подменяется пробелом
						else cout << prf[j];
					}
					SetConsoleTextAttribute(hnd, (((0 << 4) | r)));
					do { // Допечатываем слово после префикса
						if (var[q] == 95) cout << " "; // Если в оставшейся части слова содержится знак нижнего подчёркивания, то, на экране он подменяется пробелом
						else cout << var[q];
						++q;
					} while (var[q] != 32); // Пока не встретили пробел
					++q; // Переходим на следующий символ после разделяющего пробела
					++y; // Переходим на следующую строку
				}
				SetConsoleTextAttribute(hnd, (((0 << 4) | 7)));
			}
			SetConsoleCursorPosition(hnd, {h, m}); // Переходим на информационную строку
			if (c < 10) cout << " " << c; // Если в строке сообщения меньше 10-ти символов
			else cout << c;
			x = d + c; // Выставляем позицию курсора по оси X для новой итерации цикла
			y = e; // Выставляем позицию курсора по оси Y для новой итерации цикла
			ShowConsoleCursor(TRUE);
			SetConsoleCursorPosition(hnd, {x, y});
		}
		if (a == 27) { // Если был нажат Esc
			y = g + p;
			SetConsoleCursorPosition(hnd, {0, y});
			break;
		}
		sms[c] = 0; // Зануляем строку сообщения
	}
}