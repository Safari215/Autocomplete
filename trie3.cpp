#include "trie2.cpp"
BOOL ShowConsoleCursor(BOOL bShow) { // Код (функции скрытия каретки) взят с сайта "Форум программистов" у пользователя с ником "586"
    CONSOLE_CURSOR_INFO cci;
    HANDLE hStdOut;
    hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if(hStdOut == INVALID_HANDLE_VALUE) return FALSE;
    if(!GetConsoleCursorInfo(hStdOut, &cci)) return FALSE;
    cci.bVisible = bShow;
    if(!SetConsoleCursorInfo(hStdOut,&cci)) return FALSE;
    return TRUE;
}
void entTextAuto(void) {
/* Логика. Пользователю предоставляется строка для ввода текста сообщения. Есть ограничение (и счётчик) по количеству введённых символов.
Если есть чем дополнить ввод, ниже, построчно, появляются варианты автодополнения. Предлагая варианты, алгоритм учитывает регистр первого
символа в слове. Например, если это начало предложения или слово внутри предложения, то, варианты будут разными */
	while (1) {
		CUS r = 15; // Цвет шрифта для "горячих клавиш" и текста автодополнения
		system("cls");
		convUTF8toCP866(t01, rzb);
		cout << rez;
		cout << " (";
		SetConsoleTextAttribute(hnd, (((0 << 4) | r)));
		cout << "Esc";
		SetConsoleTextAttribute(hnd, (((0 << 4) | 7)));
		cout << ")" << endl;
		convUTF8toCP866(t02, rzb);
		cout << rez << endl;
		convUTF8toCP866(t03, rzb);
		cout << rez;
		cout << " (";
		SetConsoleTextAttribute(hnd, (((0 << 4) | r)));
		cout << "Enter";
		SetConsoleTextAttribute(hnd, (((0 << 4) | 7)));
		cout << ")" << endl;
		convUTF8toCP866(t04, rzc);
		cout << rez;
		US a; // Считанный после нажатия клавиши код
		UC b; // Соответствующий коду (после нажатия клавиши) символ
		US c = 0; // Счётчик символов в тексте сообщения
		short d = rzc + rzd; // Начальная позиция (отсчёт от нуля) курсора по оси X для строки с текстом сообщения
		short e = 3; // Координата (отсчёт от нуля) Y для строки с текстом сообщения
		short f = 6; // Начальная позиция (отсчёт от нуля) курсора по оси X для строки автодополнения
		short g = e + 1; // Координата Y для первой строки автодополнения
		short h = 1; // Начальная позиция курсора по оси X для информационной строки
		short m = e - 1; // Координата Y для информационной строки
		US n = 0; // Счётчик количества символов в префиксе
		US o = 0; // Количество найденных слов по префиксу
		US p = 0; // Регистратор предыдущего состояния строки автодополнения (0 - пустая, цифра - количество строк которые необходимо очистить)
		short x = d; // Отслеживаемая (в строке сообщения) координата курсора по оси X
		short y = e; // Отслеживаемая (в строке автодополнения) координата курсора по оси Y
		SetConsoleCursorPosition(hnd, {x, y});
		while (1) {
			a = _getch(); // После нажатия клавиши получаем код символа в ASCII+CP866. Для некоторых клавиш (напр. Alt) функция не возвращает код, а для функ-ных или клавиш со стрелками функцию необходимо вызывать дважды
			if ((a == 13 && c > 0) || a == 27) break; // Если был нажат Enter (и строка с текстом сообщения не пустая) или Esc
			if ((a == 0 || a == 224) && _kbhit()) a = 1000 + _getch(); // Если была нажата функцион. или клавиша со стрелкой, считываем код 2-ой раз и увелич. значение кода на 1000 что бы не пересекаться с кодами ASCII+CP866
			if (a > 31 && a < 253 && c < rzb - rzc - rzd - 1)  { // Если считанный код находится в диапазоне ASCII+CP866 и ещё не достигли конца строки
				if (o != 0 && a > 48 && a - 48 <= o) { // Если поиск по префиксу дал результат и пользователь воспользовался автодополнением
					if (a == 49) { // Если была введена цифра один
						US i = 0;
						do { // Обрабатываем выбранный пользователем вариант завершения слова
							if (var[i] == 95) { // Если в завершающей части слова встретили символ нижнего подчёркивания
								cout << " "; // Вместо символа нижнего подчёркивания на экран выводится пробел
								sms[c] = 32; // Вместо символа нижнего подчёркивания в строку с текстом сообщения заносится пробел
							}
							else {
								cout << var[i]; 
								sms[c] = var[i];
							}
							++c;
							prf[n] = var[i];
							++n;
							if (c == rzb - rzc - rzd - 1) { // Если дошли до конца строки
								n = 0;
								break;
							}
							++i;
						} while (var[i] != 32); // Продолжаем пока не встретили пробел
						prf[n] = 0;
					}
					else {
						US i = 0;
						US j = 1;
						while (1) { // Ищем необходимое слово (оно будет вторым или дальше)
							do { // Пропускаем первое или следующее неподходящее слово
								++i;
							} while (var[i] != 32); // Продолжаем пока не встретили пробел
							++i;
							++j;
							if (j == a - 48) { // Если дошли до необходимого слова
								do { // Обрабатываем выбранный пользователем вариант завершения слова
									if (var[i] == 95) {
										cout << " ";
										sms[c] = 32;
									}
									else {
										cout << var[i]; 
										sms[c] = var[i];
									}
									++c;
									prf[n] = var[i];
									++n;
									if (c == rzb - rzc - rzd - 1) { // Если дошли до конца строки
										n = 0;
										break;
									}
									++i;
								} while (var[i] != 32); // Продолжаем пока не встретили пробел
								prf[n] = 0;
								break;
							}
						}
					}
				}
				else {
					b = a; // Преобразовываем его (код) в символ
					cout << b;
					sms[c] = b;
					++c;
					if (b != 32) { // Если введённый пользователем символ не является пробелом
						prf[n] = b; // Добавляем символ в префикс
						++n;
						prf[n] = 0; // Зануляем префикс
					}
					else { // Иначе, если был введён пробел, обнуляем префикс
						n = 0;
						prf[n] = 0;
					}
				}
			}
			else if (a == 8 && c > 0) { // Если был нажат Bksp и строка сообщения не пустая (реализуем удаление последнего символа в строке сообщения и добавляем символ в префикс)
				--c;
				--x;
				SetConsoleCursorPosition(hnd, {x, y});
				cout << " "; // "Стираем" последний символ в строке текста сообщения
				if (n > 0) { // Если префикс не пустой
					--n;
					prf[n] = 0;
				}
				else if (c > 0 && sms[c - 1] != 32) { // Иначе, добавляем в префикс последнее слово из строки сообщения
					US i = c - 1; // Индекс последнего символа в строке сообщения
					do { // Считаем количество символов в последнем слове строки сообщения (считаем с конца строки)
						++n; // Счётчик количества символов (все символы кроме пробела) в последнем слове строки сообщения
						--i;
						if (i == 0) { // Если дошли до первого символа (он имеет нулевой индекс) в строке не встретив по дороге пробел
							if (sms[i] != 32) ++n; // Если первый символ в строке сообщения не является пробелом
							break;
						}
					} while (sms[i] != 32); // Продолжаем считать пока не встретим пробел
					for (i = 0; i < n; ++i) prf[i] = sms[c - n + i]; // Копируем последнее слово из строки сообщения в префикс
					prf[n] = 0;
				}
			}
			ShowConsoleCursor(FALSE);
			if (n < rzj) o = 0; // Если в префиксе не набрали достаточное количество символов
			else { // Иначе, ищем совпадения по префиксу в соответствующих структурах (только в первой, второй или обеих)
				if ((prf[0] > 159 && prf[0] < 176) || (prf[0] > 223 && prf[0] < 240) || prf[0] == 241) o = findWords(prf, 2); // Если префикс начинается с маленькой буквы ищем только во второй структуре
				else if ((prf[0] > 127 && prf[0] < 160) || prf[0] == 240) { // Если префикс начинается с прописной буквы
					if (n == c) o = findWords(prf, 3); // Если это начало строки с сообщением, ищем в двух структурах
					else {
						short s = c - n - 2; // Счётчик цикла внешний
						for (; s >= 0; --s) { // Последовательно посимвольно просматриваем строку перед префиксом в поисках ".", "!" или "?" (конца предыдущего предложения)
							if (sms[s] != 32 && sms[s] != 46 && sms[s] != 33 && sms[s] != 63) { // Если это не (" ", ".", "!" или "?"), значит, с высокой долей вероятности, префикс находится внутри предложения
								o = findWords(prf, 1); // Ищем только в первой структуре (слова начинаются с большой буквы)
								break;
							}
							else if (sms[s] == 46 || sms[s] == 33 || sms[s] == 63) { // Если это (".", "!" или "?"), т.е. префикс является (с высокой долей вероятности) началом следующего предложения в сообщении
								o = findWords(prf, 3); // Ищем в двух структурах
								break;
							}
						}
						if (s == -1) o = findWords(prf, 3); // Перед префиксом были одни пробелы, ищем в двух структурах
					}
				}
				else o = 0;
			}
			if (p != 0) { // Если строка (строки) автодополнения не пустая, то, необходимо её очистить от предыдущих данных
				y = g; // Выставляем начальное положение по оси Y
				SetConsoleCursorPosition(hnd, {f, y}); // Переходим на начальную строку автодополнения
				for (US i = 0; i < p; ++i) { // Очистка строк
					for (US j = 0; j < rzb - f; ++j) cout << " "; // Очистка очередной строки
					++y;
					SetConsoleCursorPosition(hnd, {f, y}); // Устанавливаем каретку на новую строку
				}
				p = 0; // Запомнили что всё почистили
			}
			if (c < rzb - rzc - rzd - 1 && o > 0) { // Если строка сообщения не заполнена до конца и поиск по префиксу дал результат
				y = g; // Выставляем начальное положение по оси Y
				p = o; // Запоминаем сколько строк необходимо будет потом очистить
				US q = 0; // Счётчик для количества символов (он же индекс в массиве) в строке с вариантами слов
				SetConsoleTextAttribute(hnd, (((0 << 4) | r)));
				for (US i = 1; i <= o; ++i) { // Построчно выводим варианты слов
					SetConsoleCursorPosition(hnd, {f, y}); // Переходим на строку автодополнения
					cout << i << " "; // Выводим номер хоткея
					SetConsoleTextAttribute(hnd, (((0 << 4) | 7)));
					for (US j = 0; j < n; ++j) {
						if (prf[j] == 95) cout << " "; // Если в префиксе содержится знак нижнего подчёркивания, то, на экране он подменяется пробелом
						else cout << prf[j];
					}
					SetConsoleTextAttribute(hnd, (((0 << 4) | r)));
					do { // Допечатываем слово после префикса
						if (var[q] == 95) cout << " "; // Если в оставшейся части слова содержится знак нижнего подчёркивания, то, на экране он подменяется пробелом
						else cout << var[q];
						++q;
					} while (var[q] != 32); // Пока не встретили пробел
					++q; // Переходим на следующий символ после разделяющего пробела
					++y; // Переходим на следующую строку
				}
				SetConsoleTextAttribute(hnd, (((0 << 4) | 7)));
			}
			SetConsoleCursorPosition(hnd, {h, m}); // Переходим на информационную строку
			if (c < 10) cout << " " << c; // Если в строке сообщения меньше 10-ти символов
			else cout << c;
			x = d + c; // Выставляем позицию курсора по оси X для новой итерации цикла
			y = e; // Выставляем позицию курсора по оси Y для новой итерации цикла
			ShowConsoleCursor(TRUE);
			SetConsoleCursorPosition(hnd, {x, y});
		}
		if (a == 27) { // Если был нажат Esc
			y = g + p;
			SetConsoleCursorPosition(hnd, {0, y});
			break;
		}
		sms[c] = 0; // Зануляем строку сообщения
	}
}